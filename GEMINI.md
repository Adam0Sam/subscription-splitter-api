Subscription Splitter Backend Project StructureThis document outlines a basic project structure for your .NET 8 backend, designed to support user authentication and subscription registration, while adhering to best practices like separation of concerns, clean architecture principles, and the use of MediatR and Entity Framework Core.1. Solution Structure (.sln)The project will be organized into several distinct projects within a single solution, each serving a specific architectural layer.SubscriptionSplitter.sln
├── src/
│   ├── SubscriptionSplitter.Domain/
│   ├── SubscriptionSplitter.Application/
│   ├── SubscriptionSplitter.Infrastructure/
│   └── SubscriptionSplitter.Api/
└── tests/
    └── SubscriptionSplitter.Tests/ (Optional, but highly recommended)
2. Project Breakdown2.1. SubscriptionSplitter.Domain (Domain Layer)This project contains the core business logic and domain entities. It should have no dependencies on other projects within your solution.Purpose: Defines the "what" of your application – the business rules, entities, and value objects.Dependencies: None (or only on very fundamental .NET libraries).Key Folders/Files:Entities/:User.cs: Represents your application user (can extend IdentityUser later).Subscription.cs: Represents a subscription that can be split.BaseEntity.cs: (Optional) Base class for entities with common properties like Id.ValueObjects/: (e.g., EmailAddress.cs, Money.cs - for future use)Enums/: (e.g., SubscriptionType.cs)Interfaces/:Repositories/:IUserRepository.cs: Interface for user data access.ISubscriptionRepository.cs: Interface for subscription data access.IUnitOfWork.cs: (Optional) Interface for managing transactions across multiple repositories.Exceptions/: Custom domain-specific exceptions.2.2. SubscriptionSplitter.Application (Application Layer)This project orchestrates the application's use cases, defining commands, queries, and their handlers using MediatR. It depends on SubscriptionSplitter.Domain.Purpose: Defines the "how" of your application – the specific operations it can perform. It coordinates domain objects to fulfill use cases.Dependencies: SubscriptionSplitter.Domain, MediatR, FluentValidation (for request validation).Key Folders/Files:Features/: Organize by feature (e.g., Auth, Subscriptions).Auth/:Commands/:RegisterUserCommand.cs: DTO for user registration request.LoginUserCommand.cs: DTO for user login request.Handlers/:RegisterUserCommandHandler.cs: Handles RegisterUserCommand.LoginUserCommandHandler.cs: Handles LoginUserCommand.Queries/: (e.g., GetUserByIdQuery.cs)DTOs/:RegisterUserRequest.cs: Input model for registration.LoginUserRequest.cs: Input model for login.AuthResponse.cs: Output model for authentication.Subscriptions/:Commands/:RegisterSubscriptionCommand.cs: DTO for registering a subscription.Handlers/:RegisterSubscriptionCommandHandler.cs: Handles RegisterSubscriptionCommand.DTOs/:RegisterSubscriptionRequest.cs: Input model for subscription registration.SubscriptionDto.cs: Output model for subscription data.Interfaces/:IAuthService.cs: Interface for authentication-related operations (e.g., token generation).Behaviors/: (MediatR Pipeline Behaviors)ValidationBehavior.cs: For request validation using FluentValidation.LoggingBehavior.cs: For logging requests and responses.Services/: Application-level services that coordinate multiple domain objects or external interfaces.Mappers/: (e.g., using AutoMapper) To map between domain entities and DTOs.2.3. SubscriptionSplitter.Infrastructure (Infrastructure Layer)This project provides concrete implementations for interfaces defined in SubscriptionSplitter.Domain and SubscriptionSplitter.Application. It handles data persistence, external services, and identity management. It depends on SubscriptionSplitter.Domain and SubscriptionSplitter.Application.Purpose: Provides the "details" of how the application operates – database access, external API calls, etc.Dependencies: SubscriptionSplitter.Domain, SubscriptionSplitter.Application, Entity Framework Core, ASP.NET Core Identity.Key Folders/Files:Persistence/:ApplicationDbContext.cs: Your EF Core DbContext, inheriting from IdentityDbContext.Configurations/: EF Core entity configurations (e.g., UserConfiguration.cs, SubscriptionConfiguration.cs).Migrations/: EF Core database migrations.Repositories/:UserRepository.cs: Implementation of IUserRepository.SubscriptionRepository.cs: Implementation of ISubscriptionRepository.UnitOfWork.cs: (Optional) Implementation of IUnitOfWork.Identity/:ApplicationUser.cs: Concrete IdentityUser class, potentially adding custom properties.AuthService.cs: Implementation of IAuthService (e.g., JWT token generation).Services/: Implementations of any other external service interfaces (e.g., EmailSender.cs).DependencyInjection.cs: Extension method to register infrastructure services in the DI container.2.4. SubscriptionSplitter.Api (Presentation Layer)This is your ASP.NET Core Web API project. It exposes the application's functionality through HTTP endpoints. It depends on SubscriptionSplitter.Application and SubscriptionSplitter.Infrastructure.Purpose: Exposes the application's functionality to external clients (your frontend).Dependencies: SubscriptionSplitter.Application, SubscriptionSplitter.Infrastructure.Key Folders/Files:Controllers/:AuthController.cs: Handles user registration and login endpoints.SubscriptionsController.cs: Handles subscription-related endpoints.Program.cs:Configures the ASP.NET Core host.Sets up Dependency Injection (registers services from all layers).Configures authentication (JWT Bearer).Configures EF Core.Registers MediatR.Adds Swagger/OpenAPI for API documentation.appsettings.json, appsettings.Development.json: Configuration settings (database connection string, JWT secret, etc.).Filters/: (Optional) Custom action filters (e.g., for error handling, validation).2.5. SubscriptionSplitter.Tests (Test Layer - Optional but Recommended)This project contains unit and integration tests to ensure the correctness and reliability of your application.Purpose: Verifies that your code works as expected.Dependencies: SubscriptionSplitter.Domain, SubscriptionSplitter.Application, SubscriptionSplitter.Infrastructure, testing frameworks (e.g., xUnit, Moq, FluentAssertions).Key Folders/Files:UnitTests/:Application/: Tests for MediatR handlers, application services.Core/: Tests for domain entities, value objects, domain logic.IntegrationTests/:WebAPI/: Tests for API endpoints, including database interactions.3. Core Functionality Implementation Steps3.1. Basic User Login/Signup with Local AuthCore: Define User entity.Infrastructure:Set up ApplicationDbContext inheriting from IdentityDbContext<ApplicationUser>.Configure ASP.NET Core Identity in Program.cs (in WebAPI).Implement IAuthService (e.g., AuthService) to handle user creation, password hashing, and JWT token generation using UserManager and SignInManager from ASP.NET Core Identity.Application:Create RegisterUserCommand and LoginUserCommand DTOs.Implement RegisterUserCommandHandler and LoginUserCommandHandler to interact with IAuthService and IUserRepository.WebAPI:Create AuthController with Register and Login endpoints, accepting the respective DTOs and dispatching commands via MediatR.3.2. Register a Subscription You Wish to SplitCore: Define Subscription entity.Infrastructure:Add DbSet<Subscription> to ApplicationDbContext.Implement ISubscriptionRepository (e.g., SubscriptionRepository) for CRUD operations.Application:Create RegisterSubscriptionCommand DTO.Implement RegisterSubscriptionCommandHandler to interact with ISubscriptionRepository.WebAPI:Create SubscriptionsController with an endpoint (e.g., POST /api/subscriptions) to accept RegisterSubscriptionRequest and dispatch RegisterSubscriptionCommand. Ensure this endpoint requires authentication.4. Best Practices & ConsiderationsDependency Injection: Use the built-in .NET Core DI container extensively.MediatR: Centralize request/response handling, promoting a clean separation of concerns and reducing direct dependencies between components.Entity Framework Core: Use Code-First migrations for database schema management.Authentication: Implement JWT Bearer authentication for stateless API security.Validation: Use FluentValidation with MediatR pipeline behaviors for robust input validation.Error Handling: Implement global exception handling middleware in WebAPI.Logging: Integrate a logging framework (e.g., Serilog) for structured logging.Asynchronous Programming: Use async/await throughout your application for non-blocking I/O operations.Configuration: Utilize appsettings.json for environment-specific configurations.API Versioning: (Future consideration) For evolving APIs.Health Checks: (Future consideration) To monitor application health.
